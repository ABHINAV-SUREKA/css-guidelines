/*
GENERAL RULES:
1.  Priority of selectors (in case of conflicting properties):
    a.  !important declaration > inline style in HTML > ID (#) selector > Class (.) selector or Pseudo-class(:) selector > Element selector (p, div, li, a, etc.) > Universal (*) selector
    b.  last ID selector > first ID selector (similarly for other type of selectors)
2.  Usually text-related properties can be inherited from parent selectors by child selectors, and also can be overridden by the latter.
3.  Non-text-related properties (eg: border-top, margin, padding) can't be inherited by child selectors, as that'd be impractical.
4.  CSS Box Model comprises:
    a.  inside an element: content (image, text, etc. of certain height & width) + padding + border
    b.  outside an element: margin
5.  Box-sizing:
    a.  box-sizing: content-box (default, no need to specify) - width: & height: only get applied to the content, padding + border adds to width: & height: specified (difficult as calculation is required to say, fit 2 elements side-by-side)
    b.  box-sizing: border-box - width: & height: get applied to the element (padding + border included in the width: & height: specified, and content's own area automatically gets reduced to fit width: & height:; easier as less calculation)
5.  Types of Boxes:
    a.  Inline:
            occupies exactly the width needed for its content.
            doesn't create any line-breaks before or after.
            height & width don't apply.
            padding & margin only applied horizontally.
            are placed side-by-side.
            eg: default elements: a, b, button, etc., & with css: display: inline
    b.  Block-level:
            occupies 100% of the parent's element width.
            creates line-breaks after it.
            height & width apply.
            padding & margin applied both vertically & horizontally.
            can't be placed side-by-side (elements are stacked vertically by default).
            eg: default elements: h1, p, ol, li, div, header, body, etc., & with css: display: block
    c.  Inline-block-level:
            looks inline from outside placed (side-by-side and no line-breaks).
            height & width apply.
            padding & margin applied both vertically & horizontally.
            eg: default elements: img, etc., & with css: display: inline-block
6.  Types of Flow:
    a.  Normal:
            default positioning.
            element is “in flow”, i.e. element is simply laid out according to its order in the HTML code.
            position: relative
    b.  Absolute:
            element is removed from the normal flow: “out of flow”.
            no impact on surrounding elements, might overlap them.
            we use top, bottom, left, or right to offset the element from its first relatively positioned parent container (i.e., its parent element, eg: <body>, is set to position: relative; if not, the element will be offset w.r.t. viewport).
            position: absolute
7.  Ways of building Layouts:
    a.  Float:
            old way.
            uses float: left & float: right.
            another way to absolute positioning where elements can be "out of flow", but they do have impact on surrounding inline elements (wrap around floated elements).
            parent container doesn't adjust its height acc to floated elements. for eg: if all elements in a container is floated, the container height collapses.
    b.  Flexbox:
            modern way.
            for 1-d rows without using floats.
            perfect for component layouts.
    c.  CSS Grid:
            modern way.
            for 2-d grid.
            perfect for page layouts & complex components.
 */



/* UNIVERSAL SELECTOR (*) - non-inheritable properties get applied to all the elements.
   And of course, properties mentioned in this selector (least priority) can be overridden by other selectors (higher priority).
*/
* {
    margin: 0;
    border-top: 10px solid;
    box-sizing: border-box;
}

/* COMBINING SELECTORS */
h1,
h2,
h3,
p,
li {
    color: #1098ad;
}

/* NESTED SELECTORS */
article header p {
    color: #1098ad;
}

/* PSEUDO-CLASSES (:) */
li:first-child {
    font-weight: bold;
}
li:last-child {
    font-style: italic;
}
li:nth-child(even) {
    color: red;
}
nav a:link:last-child {
    margin-right: 0;            /* trick to remove margin from right most child */
}

/* PSEUDO-ELEMENTS (::) - don't exist in HTML but can still style in CSS; inline element by default */
h1::first-letter {
    font-size: 16px;
}
p::first-line {
    color: red;
}
h3 + p::first-line {
    color: red;                 /* adjacent sibling selector (+) - trick to set style on the first-line in only the adjacent p of each h3 */
}
h2::before {                    /* ::after & ::before - imp pseudo-elements; inline elements; automatically becomes very last & first child of the selector resp; cosmetic styling with introducing any new HTML element */
    content: "TOP";             /* content property is required here */
    background-color: #ffe70e;
    display: inline-block;
}


/* STYLING LINKS */
/* Always follow std. order: LVHA */
a:link {
    color: #1098ad;
    text-decoration: none;
}
a:visited {
    color: #777;
}
a:hover {
    color: orangered;
    text-decoration: underline orangered;
}
a:active {
    background-color: black;
}

/* TRICK TO CENTER AN ELEMENT */
.container {
    margin: 0 auto;
}

/* FLOATS */
h1 {
    float: left;
}
nav {
    float: right;
}
.clear {
    clear: both;            /* trick 1 to clear float (when no other element exists to clear the float); here, .clear is an empty div inside same parent container as h1 & nav; empty divs clutter up the HTML */
}
.clearfix::after {          /* trick 2 to clear float; better approach; here, .clearfix is also a class of the parent container h1 & nav; ::after creates the last child element of the parent container */
    content: "";            /* required field in ::before & ::after */
    clear: both;
    display: block;         /* coz ::after & ::before are inline elements and clearing floats like this only work on block-level (here, div) elements */
}
